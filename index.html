<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Trái tim thủy tinh - Chúc em 20/10 vui vẻ</title>
<style>
  :root{
    --bg:#000;
    --glass-base:#c61717; /* đỏ */
    --glass-highlight:#ff6b6b;
    --text:#ff90b0;
  }
  html,body{
    height:100%;
    margin:0;
    background:var(--bg);
    font-family: "Segoe UI", Roboto, system-ui, sans-serif;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .wrap{
    height:100%;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:28px;
  }

  svg {
    width: min(68vmin,720px);
    height: auto;
    display:block;
    overflow:visible;
  }

  /* shards style */
  .shard {
    transition: transform 1s cubic-bezier(.22,.9,.3,1), opacity .9s ease;
    transform-origin: center;
    opacity:0;
    filter: drop-shadow(0 8px 18px rgba(0,0,0,.55));
    mix-blend-mode: screen;
  }

  /* when assembled: move to final and fade in */
  .assembled {
    opacity:1;
  }

  /* glass sheen (slightly blurred reflection layer) */
  .sheen {
    fill: url(#sheenGradient);
    opacity: .25;
    filter: blur(6px) saturate(1.2);
    pointer-events: none;
    mix-blend-mode: overlay;
  }

  /* caption */
  .caption {
    color: var(--text);
    font-size: clamp(16px, 2.2vmin, 22px);
    letter-spacing: .6px;
    text-transform: none;
    text-align:center;
    text-shadow: 0 6px 20px rgba(255,16,96,.08);
  }

  .caption strong{
    color:#fff;
    display:block;
    font-size: clamp(20px, 3.2vmin, 34px);
    margin-bottom:6px;
    text-shadow: 0 6px 30px rgba(255,20,120,.12);
  }

  /* subtle floating animation for whole heart after assembled */
  .float {
    animation: floaty 4s ease-in-out infinite;
  }
  @keyframes floaty {
    0% { transform: translateY(0) }
    50% { transform: translateY(-8px) }
    100% { transform: translateY(0) }
  }

  /* small pulse (scale) */
  .pulse {
    animation: pulse 1.6s cubic-bezier(.22,.9,.3,1) 1;
  }
  @keyframes pulse {
    0% { transform:scale(1) }
    40% { transform:scale(1.08) }
    100% { transform:scale(1) }
  }

  /* responsive tweak */
  @media (max-width:520px){
    svg { width: 92vw; }
  }
</style>
</head>
<body>
  <div class="wrap">
    <!-- SVG container: heart path used to calculate target positions + shards group -->
    <svg id="stage" viewBox="0 0 500 460" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
      <defs>
        <!-- red glass gradient for shards -->
        <linearGradient id="glassGrad" x1="0%" y1="0%" x2="100%" y2="100%">
          <stop offset="0%" stop-color="#ff6b6b"/>
          <stop offset="40%" stop-color="#c61717"/>
          <stop offset="100%" stop-color="#7a0000"/>
        </linearGradient>

        <!-- subtle inner gradient to simulate thickness -->
        <linearGradient id="innerGrad" x1="0%" y1="0%" x2="0%" y2="100%">
          <stop offset="0%" stop-color="rgba(255,255,255,0.15)"/>
          <stop offset="40%" stop-color="rgba(255,255,255,0.03)"/>
          <stop offset="100%" stop-color="rgba(0,0,0,0.12)"/>
        </linearGradient>

        <!-- sheen overlay -->
        <linearGradient id="sheenGradient" x1="0" y1="0" x2="1" y2="1">
          <stop offset="0%" stop-color="#fff" stop-opacity="0.9"/>
          <stop offset="40%" stop-color="#fff" stop-opacity="0.35"/>
          <stop offset="100%" stop-color="#fff" stop-opacity="0.0"/>
        </linearGradient>

        <!-- heart path (invisible) -->
        <path id="heartPath" d="M250 380
          C110 310, 30 200, 120 120
          C180 50, 260 80, 250 150
          C240 80, 320 50, 380 120
          C470 200, 390 310, 250 380 Z" fill="none"/>
      </defs>

      <!-- optional: background faint halo -->
      <circle cx="250" cy="190" r="160" fill="rgba(255,20,80,0.03)"></circle>

      <!-- group where shards will be inserted -->
      <g id="shardsGroup" transform="translate(0,0)"></g>

      <!-- sheen layer on top of heart for glossy look -->
      <g id="sheenGroup" class="sheen"></g>

      <!-- small central accent heart (finish) -->
      <g id="accent" transform="translate(0,0)" style="opacity:0; transition: opacity .9s ease;">
        <path d="M250 360
                 C170 310, 140 250, 190 210
                 C220 190, 250 210, 250 240
                 C250 210, 280 190, 310 210
                 C360 250, 330 310, 250 360 Z"
              fill="url(#glassGrad)" opacity=".9"></path>
      </g>
    </svg>

    <div class="caption">
      <strong>chúc em 20/10 vui vẻ</strong>
      <span>— Từ một trái tim thủy tinh</span>
    </div>
  </div>

<script>
/*
  Script tạo nhiều mảnh (triangles) rải ngoài sân khấu rồi "ghép" vào trong hình trái tim.
  - Tạo N shards (SVG polygons) với kích thước ngẫu nhiên.
  - Lấy random point dọc theo heartPath để làm target center cho shard.
  - Ban đầu shards được đặt rải rác ngoài khung (vòng tròn lớn).
  - Sau delay, thêm class để trigger transition tới target.
  - Sau khi hoàn thành, bật 1 số hiệu ứng (float + pulse).
*/

(function(){
  const svg = document.getElementById('stage');
  const shardsGroup = document.getElementById('shardsGroup');
  const sheenGroup = document.getElementById('sheenGroup');
  const accent = document.getElementById('accent');
  const heartPath = document.getElementById('heartPath');

  const viewBox = svg.viewBox.baseVal;
  const vbW = viewBox.width || 500;
  const vbH = viewBox.height || 460;

  const N = 60; // số mảnh - tăng giảm tùy ý
  const shards = [];

  // helper: random range
  const rand = (a,b) => a + Math.random()*(b-a);

  // get length and sample function on heart path
  const heartLen = heartPath.getTotalLength();
  function randomPointInHeart() {
    // sample a random position along the path and then jitter towards center
    const t = Math.random();
    const p = heartPath.getPointAtLength(t * heartLen);
    // jitter inside area
    const jitter = 22 + Math.random()*38;
    // bias toward center (250,190) a bit
    const cx = 250, cy = 190;
    const angle = Math.random()*Math.PI*2;
    const r = jitter * Math.random();
    const tx = p.x + Math.cos(angle)*r*0.6 + (cx-p.x)*0.05;
    const ty = p.y + Math.sin(angle)*r*0.6 + (cy-p.y)*0.05;
    return {x:tx, y:ty};
  }

  // create shards
  for(let i=0;i<N;i++){
    // triangle polygon points relative to (0,0)
    const s = Math.round(rand(18,48)); // shard scale
    // generate 3 points roughly triangular
    const p1 = {x:0, y:0};
    const p2 = {x: rand(-s*0.8, s*1.2), y: rand(-s*0.6, s*0.9)};
    const p3 = {x: rand(-s*0.6, s*0.8), y: rand(-s*1.2, s*0.8)};

    // random initial position outside canvas (around)
    const angle = Math.random()*Math.PI*2;
    const radius = rand(Math.max(vbW,vbH)*0.6, Math.max(vbW,vbH)*1.2);
    const initX = vbW/2 + Math.cos(angle)*radius;
    const initY = vbH/2 + Math.sin(angle)*radius;

    // target inside heart
    const target = randomPointInHeart();

    // create polygon element
    const poly = document.createElementNS("http://www.w3.org/2000/svg","polygon");

    // create points string offset by 0 so we can transform with translate()
    const pointsStr = `${p1.x},${p1.y} ${p2.x},${p2.y} ${p3.x},${p3.y}`;
    poly.setAttribute('points', pointsStr);

    // style: glass gradient + stroke + slight transparency
    const fillId = (Math.random() > 0.6) ? 'glassGrad' : 'innerGrad';
    poly.setAttribute('fill', `url(#${fillId})`);
    poly.setAttribute('stroke', 'rgba(255,255,255,0.18)');
    poly.setAttribute('stroke-width', Math.max(0.6, Math.random()*1.6));
    poly.setAttribute('opacity', 0.95);

    // set class
    poly.classList.add('shard');

    // random rotation
    const rot = rand(-60,60);

    // set transform origin for smoother transform
    poly.style.transformBox = 'fill-box';
    poly.style.transformOrigin = 'center';

    // insert at initial transform
    const initialTransform = `translate(${initX}px, ${initY}px) rotate(${rot}deg) scale(${rand(0.9,1.2)})`;
    poly.style.transform = initialTransform;

    // append
    shardsGroup.appendChild(poly);

    // store
    shards.push({
      el: poly,
      target: target,
      rot: rand(-8,8),
      scale: 1 + Math.random()*0.06,
      delay: rand(0.04, 0.9)
    });
  }

  // sheen overlay: draw a few thin elongated shapes to simulate glass reflections
  for(let i=0;i<6;i++){
    const g = document.createElementNS("http://www.w3.org/2000/svg","path");
    const sx = rand(150,350);
    const sy = rand(80,260);
    const w = rand(60,180);
    const h = rand(6,14);
    const d = `M ${sx} ${sy} q ${w} ${-h} ${w*1.8} ${h}`;
    g.setAttribute('d', d);
    g.setAttribute('opacity', rand(0.06,0.18));
    g.setAttribute('stroke','white');
    g.setAttribute('stroke-width', rand(2,6));
    g.setAttribute('fill','none');
    g.setAttribute('stroke-linecap','round');
    sheenGroup.appendChild(g);
  }

  // function to move shards to targets (with small random offset and rotation)
  function assemble(){
    shards.forEach((s, idx) => {
      const el = s.el;
      // small random jitter inside heart for realism
      const jitterX = rand(-8,8);
      const jitterY = rand(-8,8);
      const tx = s.target.x + jitterX;
      const ty = s.target.y + jitterY;

      // compute translate and slight rotation
      const rot = s.rot + rand(-6,6);
      const sc = s.scale * (0.9 + Math.random()*0.18);

      // create CSS transform in pixels (SVG uses px with transform style)
      // Use requestAnimationFrame with staggered delays
      setTimeout(() => {
        el.style.transform = `translate(${tx}px, ${ty}px) rotate(${rot}deg) scale(${sc})`;
        el.classList.add('assembled');
        // small additional fade-in delay handled by CSS
      }, Math.round(s.delay*900));
    });

    // after all assembled, show accent and add floating/pulse
    setTimeout(() => {
      accent.style.opacity = 1;
      // add float to group
      shardsGroup.classList.add('float');
      shardsGroup.classList.add('pulse');
    }, 1400);
  }

  // slight initial randomized wobble effect then assemble
  setTimeout(()=> {
    assemble();
  }, 420); // tiny delay so user sees shards are scattered first

  // optional: enable re-assemble on click (for demo)
  svg.addEventListener('click', () => {
    // scatter again quickly
    shards.forEach(s => {
      const el = s.el;
      const angle = Math.random()*Math.PI*2;
      const radius = rand(Math.max(vbW,vbH)*0.55, Math.max(vbW,vbH)*1.05);
      const initX = vbW/2 + Math.cos(angle)*radius;
      const initY = vbH/2 + Math.sin(angle)*radius;
      el.style.transition = "transform .8s cubic-bezier(.3,.7,.2,1), opacity .6s";
      el.style.transform = `translate(${initX}px, ${initY}px) rotate(${rand(-90,90)}deg) scale(${0.9+Math.random()*0.4})`;
      el.classList.remove('assembled');
    });
    accent.style.opacity = 0;
    shardsGroup.classList.remove('float','pulse');

    // re-assemble after short delay
    setTimeout(()=> {
      shards.forEach(s => s.delay = rand(0.04,0.9));
      assemble();
    }, 650);
  });

})();
</script>
</body>
</html>
